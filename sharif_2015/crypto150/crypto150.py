from libnum import *
import fractions

def get_primes(n):
	numbers = set(range(n, 1, -1))
	primes = []
	while numbers:
		p = numbers.pop()
		primes.append(p)
		numbers.difference_update(set(range(p*2, n+1, p)))
	return primes

# the p and q are crafted, and the top part is not very random(kp and kq), so we can do a simple collision to find part of p and q, and then use coppersmith attack

#cipher text
c = "64A3F710E3CB9B114FD112B45AC4845292D0B1FEE1468147E80FABA3CD56B1206F5C59E5D400A7F20C9BCD5B42C7197A0D07FBBA48BFBDA550C5CAFB562BEC1B1CB301D131E13233F2BD1C80EEB48956FF0BC8DB6AE2CD727FB1DAC62822331B15A6044F825D01D81036DA3CC8A3575165E813051036715CDF5F7865676DC2513AAD08C5113DFFDC4E6B13E6FFCA2FAD1AA6986D3ED9F1896C109F641074DA7DBFE62CCAD3CACE4B80332475FE3C9EC4869FCA31EE2860D45959F8583C2AEC7A00FC2FD63DBF6CBEB1C604D60CF780FE028ED0AD65DC74BC5335F96EE7CEDEA292F76B427E5F402BCC609B39302CD4A51F405C6ACF8B8A7569AAD9A9318F060B"

#modulus
n = "A4E20DDB854955794E7ABF4AE40051C0FC30488C82AB93B7DD046C1CC094A54334C97E84B523BD3F79331EBEAF5249200D729A483D5B8D944D58DF18D2CA9401B1A1A6CDA8A3AC5C234A501794B76886C426FAC35AD9615ADAB5C94B58C03CCFFA891CE0156CBC14255F019617E40DE9124FBBE70D64CD823DCA870FF76B649320927628250D47DB8DFA9BBCE9964CB3FE3D1B69845BD6FA2E6938DDA1F109E5F4E4170C845B976BBD5121107642FC00606208F9BC83322532739BCFEAF706FB2AF985EBD9769C7FBD50ECBF55566BD44FB241F9FD2DE25069AA8C744F0558514F1E9C8E4297A4D4B25D9F2B7494B466C2E6E2834BA68C5C824215018368B4FB"

def generate():
        primes = get_primes(443)
        primes.sort()
        del primes[0]
        #print primes

        pi = 1;
        for x in primes:
	        pi *= x


        for x in range(1, 2**12):
                for y in range(1, 2**12):
                        kp = x + 2**12 + 2**13 + 2**14 + 2**15 + 2**16 + 2**17 + 2**18 + 2**19
                        p = kp * pi * 2**400
        
                        kq = y + 2**12 + 2**13 + 2**14 + 2**15 + 2**16 + 2**17 + 2**18 + 2**19
	                q = kq * pi * 2**400

                        part = "%X" % (q*p)

                        if part[:2*10] in n:
                                print "%X" % p
                                print "%X" % q
                                break

#generate  partial of p, and put it in coppersmith implementation tools (online or use cryptool)
#generate()

# top part of p and q
# CD696A9DD3C18767DA330E7F18EA2B88F74885EF499EE99BE23392901E35CA83F58C19C754AB274122CA97AAFFD9E692AA20A53CDEE5CE672AF228B52A0EB1F65AB628A87C7F1B6CC900195FDB960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
# CD7D6C6FABF1730F7A04B9F3D21323661BF58B2017A2D510CDE76C623335C89CDA0CF0D77EA51AF251AD9146F6D58311C2A3C01DB18C6EDA335FF8F57FE581C561A8558D50EC415752DB742910BC0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

#got the p and q 
e = 0x10001
p = 144299940222848685214153733110344660304144248927927225494186904499495592842937728938865184611511914233674465357703431948804720019559293726714685845430627084912877192848598444717376108179511822902563959186098293320939635766298482099885173238182915991321932102606591240368970651488289284872552548559190434607447
q = 144245059483864997316184517203073096336312163518349447278779492969760750146161606776371569522895088103056082865212093431805166968588430946389831338526998726900084424430828957236538023320369476765118148928194401317313951462365588911048597017242401293395926609382786042879520305147467629849523719036035657146109

phi = (p-1)*(q-1)
d = invmod(e, phi)
c = int(c, 16)
n = int(n, 16)

msg = pow(c, d, n)
# print msg
print ("%X" % msg).decode('hex')






